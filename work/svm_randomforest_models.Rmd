---
title: "models_svm_randomforest"
author: "Sarah"
date: "11/8/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggspatial)
library(maptools)
library(tigris)
```

```{r}
# load data
pixels_data <- read.csv('pixels_data.csv')
pixels_data <- pixels_data %>%
  dplyr::select(ID, red, green, blue, ir, ndvi, Cmmn_Nm)
  #dplyr::select(-St_Wdth)

# training data
train <- sample(1:nrow(pixels_data), nrow(pixels_data)/2)

# test data
test <- pixels_data[-train, "Cmmn_Nm"]


# try grouping maples, maybe new smaller polygons, look into overlapping model results in pixels space, make a map of where western redcedar is
```

```{r}
library(randomForest)
set.seed(123)
tree_name_rf <- randomForest(formula = Cmmn_Nm ~ ., data = pixels_data %>% dplyr::select(-ID), subset = train, importance = T)
# default uses mtry = sqrt(# variables) when building random forest of classification trees

tree_name_rf
yhat_rf <- predict(tree_name_rf, newdata = pixels_data[-train, ])
confusion_matrix <- table(test, yhat_rf)

importance(tree_name_rf)
varImpPlot(tree_name_rf)
```

```{r}
library(e1071)
tree_name_svm <- svm(factor(Cmmn_Nm) ~ ., data = pixels_data)

tree_name_svm
summary(tree_name_svm)

graphics::plot(tree_name_svm, pixels_data, factor(Cmmn_Nm) ~ .)

# cross validation
tune_out <- tune(svm, Cmmn_Nm ~., data = pixels_data, kernel = "radial", 
                 ranges = list(cost = c(0.001, 0.01, 0.1, 1, 5, 10, 100)))
summary(tune_out)

# predict

```

Plot results
```{r}
# combine predictions with test data
test_dat <- cbind(yhat_rf, pixels_data[-train, ])

# "accurate" tree guess if more than half pixels in polygon are accurately predicted
poly_test_dat <- test_dat %>%
  group_by(ID) %>%
  count(ID, same = (yhat_rf == Cmmn_Nm), total = n())

poly_test <- poly_test_dat %>%
  pivot_wider(names_from = same, values_from = n)

poly_test[is.na(poly_test)] <- 0 # replace na with 0

sum(poly_test$`FALSE`)
sum(poly_test$`TRUE`)

poly_test_vector <- poly_test_dat %>%
  dplyr::filter(n/total >= 0.5) %>%
  dplyr::select(ID, same)

poly_test_vector <- poly_test %>%
  dplyr::mutate(result = case_when(`TRUE` > `FALSE` ~ "correct",
                                   `TRUE` <= `FALSE` ~ "incorrect"))

poly_test_vector %>%
  group_by(result) %>%
  count(result)

# combine with latitude info from poly_reprojected in work/geographic_join.Rmd
poly_join_reprojected@data <- poly_join_reprojected@data %>%
  left_join(poly_test_vector, by = c("id" = "ID"))

# make key to match projected data with vector using spCbind
o <- match(poly_join_reprojected@data$id, poly_test_vector$ID)
results_vector <- poly_test_vector[o,]
spCbind(obj = poly_join_reprojected, x = results_vector)

# make dataframe for ggplot
results_pts <- fortify(poly_join_reprojected, region = "id")
results_df <- merge(results_pts, poly_join_reprojected@data, by = "id")

# initial ggplot
ggplot(results_df, aes(x = long, y = lat, group = id, color = result)) + 
  geom_polygon(size = 2) +
  scale_fill_brewer() + theme_minimal() +
  theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "none")

# add city outline
mult_county <- county_subdivisions('Oregon', 'Multnomah')

poly_sf <- st_as_sf(poly_join_reprojected)

ggplot(data = poly_sf, aes(color = result)) + 
  geom_sf(size = 2) +
  scale_color_viridis_d(direction = -1)
```

