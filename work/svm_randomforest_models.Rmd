---
title: "models_svm_randomforest"
author: "Sarah"
date: "11/8/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggspatial)
library(maptools)
library(tigris)
library(caret)
```

```{r}
# load data
pixels_data <- read.csv('pixels_data.csv')
pixels_data <- pixels_data %>%
  dplyr::select(ID, red, green, blue, ir, ndvi, Cmmn_Nm)
  #dplyr::select(-St_Wdth)

# training data
train_sample <- sample(1:nrow(pixels_data), nrow(pixels_data)/2)
train <- pixels_data[train_sample,]

# test data
test <- pixels_data[-train_sample, "Cmmn_Nm"]


# try grouping maples, maybe new smaller polygons, look into overlapping model results in pixels space, make a map of where western redcedar is
```


```{r}
# random search random forest using caret package
control <- trainControl(method="repeatedcv", number=5, search="random")
rf_random <- train(Cmmn_Nm~., data=pixels_data, method="rf", trControl=control)
print(rf_random)
plot(rf_random)

 
#predict(pixels_data[-train, ], rf_random)
```



```{r}
# boosted tree using caret package
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 3)
set.seed(825)
gbmFit1 <- train(Cmmn_Nm ~ ., data = train, 
                 method = "gbm", 
                 trControl = fitControl,
                 ## This last option is actually one
                 ## for gbm() that passes through
                 verbose = FALSE)
gbmFit1
```


```{r}
# library(e1071)
# tree_name_svm <- svm(factor(Cmmn_Nm) ~ ., data = pixels_data)
# 
# tree_name_svm
# summary(tree_name_svm)
# 
# graphics::plot(tree_name_svm, pixels_data, factor(Cmmn_Nm) ~ .)
# 
# # cross validation
# tune_out <- tune(svm, Cmmn_Nm ~., data = pixels_data, kernel = "radial", 
#                  ranges = list(cost = c(0.001, 0.01, 0.1, 1, 5, 10, 100)))
# summary(tune_out)
# 
# # predict

# 10 fold cross validation
train_control <- trainControl(method="repeatedcv", number=10, repeats=3)

# fit svm model with normalized variables
svm1 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmLinear", trControl = train_control,  preProcess = c("center","scale"))
#View the model
svm1

# fit second svm model 
svm2 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmLinear", trControl = train_control,  preProcess = c("center","scale"), tuneGrid = expand.grid(C = seq(0, 2, length = 20)))
#View the model
svm2
plot(svm2)
svm2$bestTune

# fit nonlinear svm model (radial basis)
svm3 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmRadial", trControl = train_control, preProcess = c("center","scale"), tuneLength = 10)
# Print the best tuning parameter sigma and C that maximizes model accuracy
svm3
svm3$bestTune

# fit nonlinear svm model (polynomial basis)
svm4 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmPoly", trControl = train_control, preProcess = c("center","scale"), tuneLength = 4)
# Print the best tuning parameter sigma and C that maximizes model accuracy
svm4
svm4$bestTune
```

Plot results
```{r}
# combine predictions with test data
test_dat <- cbind(yhat_rf, pixels_data[-train, ])

# "accurate" tree guess if more than half pixels in polygon are accurately predicted
poly_test_dat <- test_dat %>%
  group_by(ID) %>%
  count(ID, same = (yhat_rf == Cmmn_Nm), total = n())

poly_test <- poly_test_dat %>%
  pivot_wider(names_from = same, values_from = n)

poly_test[is.na(poly_test)] <- 0 # replace na with 0

sum(poly_test$`FALSE`)
sum(poly_test$`TRUE`)

poly_test_vector <- poly_test_dat %>%
  dplyr::filter(n/total >= 0.5) %>%
  dplyr::select(ID, same)

poly_test_vector <- poly_test %>%
  dplyr::mutate(result = case_when(`TRUE` > `FALSE` ~ "correct",
                                   `TRUE` <= `FALSE` ~ "incorrect"))

poly_test_vector %>%
  group_by(result) %>%
  count(result)

# combine with latitude info from poly_reprojected in work/geographic_join.Rmd
poly_join_reprojected@data <- poly_join_reprojected@data %>%
  left_join(poly_test_vector, by = c("id" = "ID"))

# make key to match projected data with vector using spCbind
o <- match(poly_join_reprojected@data$id, poly_test_vector$ID)
results_vector <- poly_test_vector[o,]
spCbind(obj = poly_join_reprojected, x = results_vector)

# make dataframe for ggplot
results_pts <- fortify(poly_join_reprojected, region = "id")
results_df <- merge(results_pts, poly_join_reprojected@data, by = "id")

# initial ggplot
ggplot(results_df, aes(x = long, y = lat, group = id, color = result)) + 
  geom_polygon(size = 2) +
  scale_fill_brewer() + theme_minimal() +
  theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "none")

# add city outline
mult_county <- county_subdivisions('Oregon', 'Multnomah')

poly_sf <- st_as_sf(poly_join_reprojected)

ggplot(data = poly_sf, aes(color = result)) + 
  geom_sf(size = 2) +
  scale_color_viridis_d(direction = -1)
```

