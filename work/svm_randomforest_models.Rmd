---
title: "models_svm_randomforest"
author: "Sarah"
date: "11/8/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggspatial)
library(maptools)
library(tigris)
library(caret)
library(corrplot)
```

```{r}
# load data
pixels_data <- read.csv('pixels_data.csv')


# # training data
# train_sample <- sample(1:nrow(pixels_data), nrow(pixels_data)/2)
# train <- pixels_data[train_sample,]
# 
# # test data
# test <- pixels_data[-train_sample, "Cmmn_Nm"]


# try grouping maples, maybe new smaller polygons, look into overlapping model results in pixels space, make a map of where western redcedar is
```


```{r}
# load data adding different ratio predictors
pixels_data <- pixels_data %>%
  dplyr::select(red, green, blue, ir, ndvi, Cmmn_Nm) %>%
  mutate(red_blue = red/blue,
         ir_red = ir/red,
         red_green = red/green,
         blue_green = blue/green)
  
# look at correlation matrix
corr_matrix <- round(cor(pixels_data %>% select(-Cmmn_Nm)), 2)
corrplot(corr_matrix, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)

# ir_red not as highly correlated as other ratio predictors, but still highly correlated with ndvi
# red_green strongest correlation with green at -0.81
# red_blue strongest correlation with blue

pixels_data1 <- pixels_data %>%
  select(red, green, blue, ir, ndvi, Cmmn_Nm)

pixels_data2 <- pixels_data %>%
  select(red, green, blue, ir, ndvi, red_green, blue_green, Cmmn_Nm)

pixels_data3 <- pixels_data %>%
  select(red, green, blue, ir, ndvi, red_green, red_blue, blue_green, Cmmn_Nm)

# random forest

# random search random forest using caret package
control <- trainControl(method="repeatedcv", number=10, search="random")
rf_random1 <- train(Cmmn_Nm~., data=pixels_data1, method="rf", trControl=control)
rf_random2 <- train(Cmmn_Nm~., data=pixels_data2, method="rf", trControl=control)
rf_random3 <- train(Cmmn_Nm~., data=pixels_data3, method="rf", trControl=control)


#predict(pixels_data[-train, ], rf_random)
```


```{r}
# compare rf models

# collect resamples
results <- rbind(cbind(rf_random1$resample, Model = rep("5", nrow(rf_random1$resample))), 
                 cbind(rf_random2$resample, Model = rep("7", nrow(rf_random2$resample))), 
                 cbind(rf_random3$resample, Model = rep("8", nrow(rf_random3$resample))))

ggplot(results, aes(x = Model, y = Accuracy, fill = Model)) +
  geom_boxplot(alpha = 0.6) +
  theme_minimal() + 
  scale_fill_viridis_d() +
  labs(title = "Model Accuracy of Random Forest Models with 10-Fold CV", x = " ", fill = "Number of Predictors") + 
  theme(axis.text.x = element_blank())

confusionMatrix(rf_random1,  mode = "prec_recall")
# rf_random1 western redcedar prediction accuracy: 0.35
# rf_random2 western redcedar prediction accuracy: 0.38
# rf_random3 western redcedar prediction accuracy: 0.37
```


```{r}
# reload data
pixels_data <- pixels_data %>%
  dplyr::select(red, green, blue, ir, ndvi, Cmmn_Nm)

# 10 fold cross validation
train_control <- trainControl(method="cv", number=10)

# fit svm model with normalized variables
svm1 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmLinear", trControl = train_control,  preProcess = c("center","scale"))

# fit nonlinear svm model (radial basis)
svm2 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmRadial", trControl = train_control, preProcess = c("center","scale"), tuneLength = 10)

# fit nonlinear svm model (polynomial basis)
svm3 <- train(Cmmn_Nm ~., data = pixels_data, method = "svmPoly", trControl = train_control, preProcess = c("center","scale"))
```

```{r}
# compare svm models

# collect resamples
results <- rbind(cbind(svm1$resample, Model = rep("svmLinear", nrow(svm1$resample))), 
                 cbind(svm2$resample, Model = rep("svmRadial", nrow(svm2$resample))), 
                 cbind(svm3$resample, Model = rep("svmPoly", nrow(svm3$resample))))

ggplot(results, aes(x = Model, y = Accuracy, fill = Model)) +
  geom_boxplot(alpha = 0.6) +
  theme_minimal() + 
  scale_fill_viridis_d() +
  labs(title = "Model Accuracy of SVM Models with 10-Fold CV", x = " ", fill = " ") + 
  theme(axis.text.x = element_blank())

confusionMatrix(svm1,  mode = "prec_recall")
# svm1 western redcedar prediction accuracy: 0.32
# svm2 western redcedar prediction accuracy: 0.41
# svm3 western redcedar prediction accuracy: 0.34
```


```{r}
# boosted tree using caret package
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           repeats = 3)
set.seed(825)
gbmFit1 <- train(Cmmn_Nm ~ ., data = train, 
                 method = "gbm", 
                 trControl = fitControl,
                 ## This last option is actually one
                 ## for gbm() that passes through
                 verbose = FALSE)
gbmFit1
```

Plot results
```{r}
# combine predictions with test data
test_dat <- cbind(yhat_rf, pixels_data[-train, ])

# "accurate" tree guess if more than half pixels in polygon are accurately predicted
poly_test_dat <- test_dat %>%
  group_by(ID) %>%
  count(ID, same = (yhat_rf == Cmmn_Nm), total = n())

poly_test <- poly_test_dat %>%
  pivot_wider(names_from = same, values_from = n)

poly_test[is.na(poly_test)] <- 0 # replace na with 0

sum(poly_test$`FALSE`)
sum(poly_test$`TRUE`)

poly_test_vector <- poly_test_dat %>%
  dplyr::filter(n/total >= 0.5) %>%
  dplyr::select(ID, same)

poly_test_vector <- poly_test %>%
  dplyr::mutate(result = case_when(`TRUE` > `FALSE` ~ "correct",
                                   `TRUE` <= `FALSE` ~ "incorrect"))

poly_test_vector %>%
  group_by(result) %>%
  count(result)

# combine with latitude info from poly_reprojected in work/geographic_join.Rmd
poly_join_reprojected@data <- poly_join_reprojected@data %>%
  left_join(poly_test_vector, by = c("id" = "ID"))

# make key to match projected data with vector using spCbind
o <- match(poly_join_reprojected@data$id, poly_test_vector$ID)
results_vector <- poly_test_vector[o,]
spCbind(obj = poly_join_reprojected, x = results_vector)

# make dataframe for ggplot
results_pts <- fortify(poly_join_reprojected, region = "id")
results_df <- merge(results_pts, poly_join_reprojected@data, by = "id")

# initial ggplot
ggplot(results_df, aes(x = long, y = lat, group = id, color = result)) + 
  geom_polygon(size = 2) +
  scale_fill_brewer() + theme_minimal() +
  theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "none")

# add city outline
mult_county <- county_subdivisions('Oregon', 'Multnomah')

poly_sf <- st_as_sf(poly_join_reprojected)

ggplot(data = poly_sf, aes(color = result)) + 
  geom_sf(size = 2) +
  scale_color_viridis_d(direction = -1)
```

